#include "configana.h"
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <iterator>
#include <functional>
#include <numeric>
#include <string>
#include <climits>
#include <cassert>
#include <cstdlib>
#include <sstream>
#include <utility> 
#include <typeinfo>
#include "TROOT.h"
#include "TSystem.h"
#include "TChain.h"
#include "TClonesArray.h"
#include "TFrame.h"
#include "TRandom.h"
#include "TStopwatch.h"
#include "TFile.h"
#include "TH1K.h"
#include "TH1.h"
#include "TH2.h"
#include "TProfile.h"

#include "AnaUtil.h"
#include "PhysicsObjSelector.h"


using std::cout;
using std::cerr;
using std::endl;
using std::string;
using std::ostringstream;
using std::vector;
using std::map;
using std::pair;
using std::abs;
using std::max;
using std::sqrt;
using std::sort;
using std::setprecision;
using std::setw;
PhysicsObjSelector::PhysicsObjSelector()
: AnaBase(),
  searchedEle_(false),
  searchedMu_(false),
  searchedPhoton_(false)
{
}
bool PhysicsObjSelector::beginJob() {
    AnaBase::beginJob();
    histf()->cd();
    histf()->mkdir("ObjectSelection");
    return true;
}
void PhysicsObjSelector::bookHistograms() {
    histf()->cd();
    histf()->cd("ObjectSelection");
    new TH1D("muCutFlow","Muon Cut Flow",10, -0.5, 10.5);
    new TH1D("eleCutFlow","Electron Cut Flow",8, -0.5, 7.5);
}
//loose muon////
void PhysicsObjSelector::muonSelector(double wt) {
    histf()->cd();
    histf()->cd("ObjectSelection");
    std::vector<vhtm::PackedPFCandidate> photemp;//empty vector of PF candidates
    for (auto it = muonColl()->begin(); it != muonColl()->end(); ++it) {
        const vhtm::Muon& muon = (*it);
        AnaUtil::fillHist1D("muCutFlow", 0, wt);
        
        if (muon.pt <= AnaUtil::cutValue(muonCutMap(), "pt"))                             continue;
        AnaUtil::fillHist1D("muCutFlow", 1, wt);
        
        if (std::fabs(muon.eta) >= AnaUtil::cutValue(muonCutMap(), "eta"))                continue;
        AnaUtil::fillHist1D("muCutFlow", 2, wt);
        
        if ( std::fabs(muon.dxyPV) >= AnaUtil::cutValue(muonCutMap(), "dxyPV") )                      continue;
        AnaUtil::fillHist1D("muCutFlow", 3, wt);
        
        if (std::fabs(muon.dzPV) >= AnaUtil::cutValue(muonCutMap(), "dzPV") )             continue;
        AnaUtil::fillHist1D("muCutFlow", 4, wt);
        
        bool muType = muon.isGlobalMuon || (muon.isTrackerMuon && muon.matches > 0);
        if (!muType)                                                                      continue;
        AnaUtil::fillHist1D("muCutFlow", 5, wt);
        
        if (muon.muonBestTrackType == 2)                                                  continue;
        AnaUtil::fillHist1D("muCutFlow", 6, wt);
        
        if (std::fabs(muon.dB3D/muon.edB3D) >= AnaUtil::cutValue(muonCutMap(), "SIP3D"))  continue;
        AnaUtil::fillHist1D("muCutFlow", 7, wt);
        
        if (!muon.isghostCleaned)                                                         continue;
        AnaUtil::fillHist1D("muCutFlow", 8, wt);
        
        // loose muon
        loosemuVec_.push_back(muon);
        
        // attach an empty PackedPFCandidate vector to each loose Muon
        std::vector<vhtm::PackedPFCandidate> phov;
        looseMuPhotonPairVec_.push_back({muon, phov});
        
        // tight muon
        if (muon.isPFMuon) {
            AnaUtil::fillHist1D("muCutFlow", 9, wt);
            tightmuVec_.push_back(muon);
        }
    }
    if (loosemuVec_.size() > 1)
        std::sort(loosemuVec_.begin(), loosemuVec_.end(), PtComparator<vhtm::Muon>());
    if (tightmuVec_.size() > 1)           
        std::sort(tightmuVec_.begin(), tightmuVec_.end(), PtComparator<vhtm::Muon>());
    
    searchedMu_ = true;
    
}
//////////////////electron selecton /////////////////
void PhysicsObjSelector::electronSelector(double wt) {
    histf()->cd();
    histf()->cd("ObjectSelection");
    
    if (!searchedMu_) muonSelector();

    for (auto it = electronColl()->begin(); it != electronColl()->end(); ++it) {
        const vhtm::Electron& electron = (*it);
        
        AnaUtil::fillHist1D("eleCutFlow",0,1);
        AnaUtil::fillHist1D("eleCutFlow", 0, wt);
        
        if (electron.pt <= AnaUtil::cutValue(electronCutMap(), "pt"))                                continue;
        AnaUtil::fillHist1D("eleCutFlow", 1, wt);
        
        if (std::fabs(electron.eta) >= AnaUtil::cutValue(electronCutMap(), "eta"))                   continue;
        AnaUtil::fillHist1D("eleCutFlow", 2, wt);
        
        if ( std::fabs(electron.dxyPV) >= AnaUtil::cutValue(electronCutMap(), "dxyPV"))                          continue;
        AnaUtil::fillHist1D("eleCutFlow", 3, wt);
        
        if (std::fabs(electron.dzPV) >= AnaUtil::cutValue(electronCutMap(), "dzPV"))                 continue;
        AnaUtil::fillHist1D("eleCutFlow", 4, wt);
        
        if (electron.missingHits > AnaUtil::cutValue(electronCutMap(), "missingHits"))               continue;
        AnaUtil::fillHist1D("eleCutFlow", 5, wt);
        
        if (std::fabs(electron.dB3D/electron.edB3D) >= AnaUtil::cutValue(electronCutMap(), "SIP3D")) continue;
        AnaUtil::fillHist1D("eleCutFlow", 6, wt);
        
        // Cross cleaning
        if (!crossCleaned(electron))  continue;
        
        // loose electrons
        looseeleVec_.push_back(electron);
        
        // attach an empty PackedPFCandidate vector to each loose electron
        std::vector<vhtm::PackedPFCandidate> phov;
        looseElePhotonPairVec_.push_back({electron, phov});
        
        // tight electrons
        if (electronBDT(electron)) {
            AnaUtil::fillHist1D("eleCutFlow", 7, wt);
            tighteleVec_.push_back(electron);
        }
    }
    if (looseeleVec_.size() > 1)
        std::sort(looseeleVec_.begin(), looseeleVec_.end(), PtComparator<vhtm::Electron>());
    if (tighteleVec_.size() > 1) 
        std::sort(tighteleVec_.begin(), tighteleVec_.end(), PtComparator<vhtm::Electron>());
    searchedEle_ = true;

}
//packed pf photon///////
void PhysicsObjSelector::pfphotonSelector(double wt) {
    if (!searchedMu_)  muonSelector();
    if (!searchedEle_) electronSelector();
    
    // -- from twiki --
    // FSR Photon selection: for each photon, consider the closest lepton:
    // Note: Multiple photons can be attached to a lepton
    // Muons
    
//Now select FSR photons for each lepton
//Note->Multiple photons can be attached to a lepton
//Screening for those will be done later down the analysis chain
    for( auto& pfPho: *packedPFCandidateColl() ) {
        
      if( pfPho.pdgId != 22 || pfPho.pt <= 2. || std::abs(pfPho.eta) >= 2.4 )   continue;
        
      if (!passedSuperClusterVeto(pfPho)) continue;
        
      std::pair<int,std::string> lepidxtype;
      findClosestLepton(pfPho,lepidxtype);
      if( lepidxtype.first == -1 )              continue;
      if( lepidxtype.second == "muon" ) {
            looseMuPhotonPairVec_.at( lepidxtype.first ).second.push_back(pfPho);
      } else if( lepidxtype.second == "electron" ) {
            looseElePhotonPairVec_.at( lepidxtype.first ).second.push_back(pfPho);
      }
  
     }
}

bool PhysicsObjSelector::electronBDT(const vhtm::Electron& electron) {
    double scEta = std::fabs(electron.scEta);
    double elePt = electron.pt;
    double BDT = electron.BDT;
    bool isBDT = (elePt <= 10 && ((scEta < 0.8 && BDT > -0.202)                     ||
                                  ((scEta >= 0.8 && scEta < 1.479) && BDT > -0.444) ||
                                  (scEta >= 1.479 && BDT > 0.264)))                 ||
    (elePt >  10 && ((scEta < 0.8 && BDT > -0.110)                     ||
                     ((scEta >= 0.8 && scEta < 1.479) && BDT > -0.284) ||
                     (scEta >= 1.479 && BDT > -0.212)));
    return isBDT;
}
bool PhysicsObjSelector::passedSuperClusterVeto(const vhtm::PackedPFCandidate& pfcand) const {
    // Supercluster veto: remove all PF photons that match with any electron passing loose ID and SIP cuts;
    // matching is according to (|deta| < 2, |dphi| < 0.05) OR (dR < 0.15), with respect to the electron's supercluster.
    bool passedVeto = true;
    for (const auto& ele: looseeleVec_) {
        auto deta = ele.scEta - pfcand.eta;
        auto dphi = std::abs(ele.scPhi - pfcand.phi);
        if (dphi > static_cast<float>(M_PI)) dphi -= 2 * static_cast<float>(M_PI);
        float dR = std::sqrt(deta * deta + dphi * dphi);
        if (dR < 0.15) {
            passedVeto = false;
            break;
        }
    }
    return passedVeto;
}
void PhysicsObjSelector::findClosestLepton(const vhtm::PackedPFCandidate& pfPho, std::pair<int,std::string>&  lepidxtype) const {
    
       double dRmin = 0.05;
       TLorentzVector phoP4;
       //phoP4 = getP4(pfPho);
       phoP4.SetPtEtaPhiE(pfPho.pt, pfPho.eta, pfPho.phi, pfPho.energy);
        //finding closest muon/electron
        for( unsigned int im = 0; im<loosemuVec_.size(); im++ ) {
            //TLorentzVector muP4 = getP4(loosemuVec_.at(im));
            TLorentzVector muP4;
            muP4.SetPtEtaPhiE(loosemuVec_.at(im).pt, loosemuVec_.at(im).eta, loosemuVec_.at(im).phi,loosemuVec_.at(im).energy);
            double dR = muP4.DeltaR(phoP4);
            if( dR < dRmin ) {
                dRmin = dR;
                lepidxtype.first = im;
                lepidxtype.second = "muon";
            }
        }
        
        for( unsigned int ie = 0; ie<looseeleVec_.size(); ie++ ) {
            //TLorentzVector eleP4 = getP4(looseeleVec_.at(ie));
            TLorentzVector eleP4;
            eleP4.SetPtEtaPhiE(looseeleVec_.at(ie).pt, looseeleVec_.at(ie).eta, looseeleVec_.at(ie).phi, looseeleVec_.at(ie).energy);
            double dR = eleP4.DeltaR(phoP4);
            if( dR < dRmin ) {
                dRmin = dR;
                lepidxtype.first = ie;
                lepidxtype.second = "electron";
            }
        }
    
    bool leptonMatched = false;
    if (dRmin < 0.07) {
        if (phoP4.Pt() > 2.) leptonMatched = true;
    } else if (dRmin >= 0.07) {
        if (pfPho.pt > 4.) {
            double PFdbiso = pfPho.isolationMap.at("c30").at(0) +
                             std::max(0.0, pfPho.isolationMap.at("c30").at(2)
                                         + pfPho.isolationMap.at("c30").at(3)
                                         + pfPho.isolationMap.at("c30").at(4));
            if (PFdbiso/pfPho.pt < 1.) leptonMatched = true;
        }
    }
    if (!leptonMatched) {
        lepidxtype.first = -1;
        lepidxtype.second = "";
    }
}
///////////////////////////////////////////////////////////////////////////
void PhysicsObjSelector::leptonCrossCleaning() {
  vector<pair<vhtm::Electron, vector<vhtm::PackedPFCandidate> > > list;
  for (const auto& it: tightElePhotonPairVec_) 
    if (crossCleaned(it.first)) list.push_back(it);

  tightElePhotonPairVec_.clear();
  tightElePhotonPairVec_ = list;
}
bool PhysicsObjSelector::crossCleaned(const vhtm::Electron& electron) const {
  bool flag = true;
  for (const auto& mu: tightmuVec_) {
    if (getP4(electron).DeltaR(getP4(mu)) < 0.05) {
      flag = false;
      break;
    }
  }
  return flag;
}
///////////////////////////////////////////////////////////////////////////////////////
void PhysicsObjSelector::findObjects(double wt) {
  // muonSelector must precede electronSelector
  muonSelector(wt);
  electronSelector(wt);
  
  // after electrons and muons are found, find photons
  pfphotonSelector();
}
////////////////////clear lists/////////////////
void PhysicsObjSelector::clear() {
  clearEvent();  
    loosemuVec_.clear();
    tightmuVec_.clear();
    looseeleVec_.clear();
    tighteleVec_.clear();
    photonVec_.clear();
    
    looseElePhotonPairVec_.clear();
    tightElePhotonPairVec_.clear();
    looseMuPhotonPairVec_.clear();
    tightMuPhotonPairVec_.clear();
    
    searchedMu_ = false;
    searchedEle_ = false;
    searchedPhoton_ = false;
 }















