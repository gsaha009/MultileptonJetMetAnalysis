#include "configana.h"
#include <iostream>
#include <iomanip>
#include <algorithm>
#include <iterator>
#include <functional>
#include <numeric>
#include <string>
#include <climits>
#include <cassert>
#include <cstdlib>
#include <sstream>
#include <utility> 
#include <typeinfo>
#include "TROOT.h"
#include "TSystem.h"
#include "TChain.h"
#include "TClonesArray.h"
#include "TFrame.h"
#include "TRandom.h"
#include "TStopwatch.h"
#include "TFile.h"
#include "TH1K.h"
#include "TH1.h"
#include "TH2.h"
#include "TProfile.h"

#include "AnaUtil.h"
#include "LeptonSync.h"


using std::cout;
using std::cerr;
using std::endl;
using std::string;
using std::ostringstream;
using std::vector;
using std::map;
using std::pair;
using std::abs;
using std::max;
using std::sqrt;
using std::sort;
using std::setprecision;
using std::setw;
LeptonSync::LeptonSync()
: AnaBase(),
  _dumpEvent(false)
{
// searchedEle_ = false;
// searchedMu_ = false;
// searchedPhoton_ = false;
    
}
// -------------------------------------------------------
// Prepare for the run, do necessary initialisation etc.
// -------------------------------------------------------
bool LeptonSync::beginJob()
{
    AnaBase::beginJob();
    
    // Open the output ROOT file
    histf()->cd();
    bookHistograms();
    
    return true;
}
// ---------------
// Book histograms
// ---------------
void LeptonSync::bookHistograms()
{
    
    new TH1D("muCutFlow","",30,-0.5,29.5);
    new TH1D("eleCutFlow","",30,-0.5,29.5);
}
void LeptonSync::eventLoop()
{
    // Initialize analysis
    if (!beginJob()) return;
    int nPrint = max(10000, nEvents()/1000);
    
    Options op;
    op.verbose = false;
    op.usesbit = true;  // Crucial
    op.printselected = false;
    
    
    // --------------------
    // Start the event loop
    // --------------------
    string lastFile;
    std::cout<<"Bunch Crossing>>>>"<<bunchCrossing()<<std::endl;
    //int n4mu=0,n2e2mu=0,n4e=0,nZ1clash=0,ntauev=0;
    for (int ev = 0; ev < nEvents(); ++ev) {
        // clearEvent();
        clearLists();
        int lflag = chain()->LoadTree(ev);
        int nbytes = getEntry(lflag);    // returns total bytes read
        string currentFile(gSystem->BaseName(chain()->GetCurrentFile()->GetName()));
        const vhtm::Event& evt = eventColl()->at(0);
        
        histf()->cd();
        
        //For data or for MC without pileup
        puevWt_ = 1;
        /*
         if (isMC()) {
         int npu = 0;
         puevWt_ = wtPileUp(npu);
         }
         */
        // Show status of the run
        int run   = evt.run;
        int event = evt.event;
        int lumis = evt.lumis;
        
        // Show status of the run
        if (currentFile != lastFile)
            cout << "Tree# " << setw(4) << chain()->GetTreeNumber()
            << " ==> " << currentFile
            << " <<< Run# " << run
            << " Lumis# " << lumis
            << " Event# " << setw(8) << event << " >>> "
            << " Events proc. " << setw(8) << ev
            << endl;
        lastFile = currentFile;
        
        // Show the status
        if (ev%nPrint == 0)
            cout << "Tree# " << setw(4) << chain()->GetTreeNumber()
            << " ==> " << chain()->GetCurrentFile()->GetName()
            << " <<< Run# " << run
            << " Lumis# " << lumis
            << " Event# " << setw(8) << event << " >>> "
            << " Events proc. " << setw(8) << ev
            << endl;
        // check trigger
        //if (useTrigger() )
        muonSelector();
        electronSelector();
    }
}
//loose muon////
void LeptonSync::muonSelector() {
    //std::cout<< AnaUtil::cutValue(muonCutMap(), "pt") << std::endl;
    std::cout<<"Muon Collection size="<<muonColl()->size()<<std::endl;
 for (auto it = muonColl()->begin(); it != muonColl()->end(); ++it) {
    const vhtm::Muon& muon = (*it);
     AnaUtil::fillHist1D("muCutFlow",0,1);

    //bool muType = !muon.isGlobalMuon && ( !muon.isTrackerMuon || !muon.isAllArbitrated );
    bool muType = muon.isGlobalMuon || ( muon.isTrackerMuon && muon.isAllArbitrated );
     if( muon.pt < AnaUtil::cutValue(muonCutMap(), "pt") )   continue;
     AnaUtil::fillHist1D("muCutFlow",1,1);
     if( std::fabs(muon.eta) > AnaUtil::cutValue(muonCutMap(), "eta") )  continue;
     AnaUtil::fillHist1D("muCutFlow",2,1);
     if( muon.dxyPV > AnaUtil::cutValue(muonCutMap(), "dxyPV") )        continue;
     AnaUtil::fillHist1D("muCutFlow",3,1);
     if( std::fabs(muon.dzPV) > AnaUtil::cutValue(muonCutMap(), "dzPV") ) continue;
     AnaUtil::fillHist1D("muCutFlow",4,1);
     if( !muType )                           continue;
     AnaUtil::fillHist1D("muCutFlow",5,1);
     //if( std::fabs(muon.dB3D/muon.edB3D) > AnaUtil::cutValue(muonCutMap(), "SIP3D") )  continue;
     AnaUtil::fillHist1D("muCutFlow",6,1);
    loosemuVec_.push_back(muon);
     if( muon.isPFMuon ) {
         AnaUtil::fillHist1D("muCutFlow",7,1);
         tightmuVec_.push_back(muon);
     }
 }
 if( !loosemuVec_.empty() )           
   std::sort(loosemuVec_.begin(),loosemuVec_.end(),PtComparator<vhtm::Muon>());
 if( !tightmuVec_.empty() )           
   std::sort(tightmuVec_.begin(),tightmuVec_.end(),PtComparator<vhtm::Muon>());
 ///searchedMu_ = true;
   // std::cout << "POBJLoose/Tight mu=" << loosemuVec_.size() << "/" << tightmuVec_.size() << std::endl;
}
//////////////////electron selecton /////////////////
void LeptonSync::electronSelector() {
  for (auto it = electronColl()->begin(); it != electronColl()->end(); ++it) {
      AnaUtil::fillHist1D("eleCutFlow",0,1);
    const vhtm::Electron& electron = (*it); 
    double elePt = electron.pt;
    
      
    double eleta  = std::fabs(electron.eta);
    bool   etaCut = (eleta >= AnaUtil::cutValue(electronCutMap(), "etaLow") &&
	             eleta <= AnaUtil::cutValue(electronCutMap(), "etaUp")) ||
                     eleta  >= AnaUtil::cutValue(electronCutMap(), "eta");
      if ( elePt <= AnaUtil::cutValue(electronCutMap(), "pt")  )          continue;
      AnaUtil::fillHist1D("eleCutFlow",1,1);
      if( etaCut )     continue;
      AnaUtil::fillHist1D("eleCutFlow",2,1);
      if( electron.dxyPV > AnaUtil::cutValue(electronCutMap(), "dxyPV") )      continue;
      AnaUtil::fillHist1D("eleCutFlow",3,1);
      if( std::fabs(electron.dzPV) > AnaUtil::cutValue(electronCutMap(), "dzPV") )    continue;
      AnaUtil::fillHist1D("eleCutFlow",4,1);
      if( electron.missingHits > AnaUtil::cutValue(electronCutMap(), "missingHits") ) continue;
      AnaUtil::fillHist1D("eleCutFlow",5,1);
      //if( std::fabs(electron.dB3D/electron.edB3D)  > AnaUtil::cutValue(electronCutMap(), "SIP3D") ) continue;
      AnaUtil::fillHist1D("eleCutFlow",6,1);
      
      looseeleVec_.push_back(electron);

      double fSCeta = std::fabs(electron.scEta);
      double BDT=electron.BDT;
      bool isBDT = (elePt <= 10 && (( fSCeta < 0.8 && BDT > 0.47)   ||
                   (fSCeta >= 0.8 && fSCeta < 1.479 && BDT > 0.004) ||
                   (fSCeta >= 1.479               && BDT > 0.295))) || 
                   (elePt >  10 && ((fSCeta < 0.8 && BDT > -0.34)      ||
                   (fSCeta >= 0.8 && fSCeta < 1.479 && BDT > -0.65) || 
                   (fSCeta >= 1.479               && BDT > 0.6)));
      if( isBDT ) {
          AnaUtil::fillHist1D("eleCutFlow",7,1);
          tighteleVec_.push_back(electron);
      }
 
  }
 if( !looseeleVec_.empty() ) 
   std::sort(looseeleVec_.begin(),looseeleVec_.end(),PtComparator<vhtm::Electron>());
 if( !tighteleVec_.empty() ) 
   std::sort(tighteleVec_.begin(),tighteleVec_.end(),PtComparator<vhtm::Electron>());
 //searchedEle_ = true;
    //std::cout << "POBJLoose/Tight e=" << looseeleVec_.size() << "/" << tighteleVec_.size() << std::endl;
}
//packed pf photon///////
void LeptonSync::pfphotonSelector() {
   // if( !searchedEle_ ) {
    ///    electronSelector();//std::cout<<" POBJ point 1>>";
  //  }
  //  if( !searchedMu_ ){
       // std::cout<<" POBJ point 2>>";
   //     muonSelector();
   // }
    //std::cout<<"mu size>>"<<loosemuVec_.size()<<">>>>>elesize>>>"<<looseeleVec_.size()<<std::endl;
//Pre-selection of PF Photons
    std::vector<TLorentzVector> eleP4vec;
  if( !looseeleVec_.empty() ) {
    for( auto& e : looseeleVec_ ) {
      TLorentzVector eP4;
      eP4.SetPtEtaPhiE(e.pt,e.eta,e.phi,e.energy);
      eleP4vec.push_back(eP4);
    }
  }
    //std::cout<<" POBJ point 3>>";
    std::vector<vhtm::PackedPFCandidate> pfphotonVectemp;//preselected PFPhotons
      //std::cout<<"ppfsize>>>>"<<packedPFCandidateColl()->size()<<endl;
    for (auto it = packedPFCandidateColl()->begin(); it != packedPFCandidateColl()->end(); ++it) {
      const vhtm::PackedPFCandidate& pfphoton = (*it);
       // std::cout<<" POBJ point 3a>>";
      if( pfphoton.pdgId != 22 || pfphoton.pt < 2. || std::abs(pfphoton.eta) > 2.4 )   continue;
      TLorentzVector pfPhoP4;
      pfPhoP4.SetPtEtaPhiE(pfphoton.pt,pfphoton.eta,pfphoton.phi,pfphoton.energy);
      bool eleVeto = true;
        //std::cout<<" POBJ point 3b>>";
      for( auto& eP4 : eleP4vec ) {
        if( eP4.DeltaR(pfPhoP4) < 0.15 ) {
          eleVeto = false;
          break;
        }
      }
        //std::cout<<" POBJ point 3c>>";
      if( !eleVeto )   continue;
      pfphotonVectemp.push_back( pfphoton );//photon preselection
    }
      //std::cout<<" POBJ point 4>>";
//Now select FSR photons for each lepton
//Note->Multiple photons can be attached to a lepton
//Screening for those will be done later down the analysis chain
      //std::cout<<"POBJ loosemuVec_ size="<<loosemuVec_.size() << "\n";
      //std::cout<<"POBJ pfphotonVectemp size="<<pfphotonVectemp.size() << "\n";
    for( auto& mu : loosemuVec_ ) {
      TLorentzVector muP4;
      muP4.SetPtEtaPhiE(mu.pt,mu.eta,mu.phi,mu.energy);
      std::vector<vhtm::PackedPFCandidate> photemp; 
      for( auto& pfPho : pfphotonVectemp ) { 
        TLorentzVector phoP4;
        phoP4.SetPtEtaPhiE(pfPho.pt,pfPho.eta,pfPho.phi,pfPho.energy); 
        if( muP4.DeltaR(phoP4) < 0.07 && pfPho.pt > 2. ) {
          photemp.push_back(pfPho);
          pfphotonVec_.push_back(pfPho);
        } else if( muP4.DeltaR(phoP4) >= 0.07 && muP4.DeltaR(phoP4) < 0.5 && pfPho.pt > 4. ) {
          //double PFdbiso = ch + std::max(0.0, nu-0.5*pu); 
          double PFdbiso = pfPho.isolationMap.at("c30").at(0) + 
                           std::max(0.0, pfPho.isolationMap.at("c30").at(1) -
                                         0.5*pfPho.isolationMap.at("c30").at(2));
          if( PFdbiso/pfPho.pt < 1.) {
            photemp.push_back(pfPho);
            pfphotonVec_.push_back(pfPho);
          }
        } 
      }
       // if ( photemp.empty() ) {
       //     vhtm::PackedPFCandidate pho;
       //     photemp.push_back(pho);
       // }
        std::pair< vhtm::Muon, std::vector<vhtm::PackedPFCandidate> > mufsrtemp = std::make_pair(mu,photemp);
        looseMuPhoFSRpair_.push_back( mufsrtemp );
    }
      std::cout<<"POBJ loosemuVec//looseMuPhoFSRpair size="<<loosemuVec_.size()<<"//"<<looseMuPhoFSRpair_.size() << "\n";
//For electron
    for( auto& ele : looseeleVec_ ) {
      TLorentzVector eleP4;
      eleP4.SetPtEtaPhiE(ele.pt,ele.eta,ele.phi,ele.energy);
      std::vector<vhtm::PackedPFCandidate> photemp; 
      for( auto& pfPho : pfphotonVectemp ) { 
        TLorentzVector phoP4;
        phoP4.SetPtEtaPhiE(pfPho.pt,pfPho.eta,pfPho.phi,pfPho.energy); 
        if( eleP4.DeltaR(phoP4) < 0.07 && pfPho.pt > 2. ) {
          photemp.push_back(pfPho);
          pfphotonVec_.push_back(pfPho);
        } else if( eleP4.DeltaR(phoP4) >= 0.07 && eleP4.DeltaR(phoP4) < 0.5 && pfPho.pt > 4. ) {
          //double PFdbiso = ch + std::max(0.0, nu-0.5*pu); 
          double PFdbiso = pfPho.isolationMap.at("c30").at(0) + 
                           std::max(0.0, pfPho.isolationMap.at("c30").at(1) -
                                         0.5*pfPho.isolationMap.at("c30").at(2));
          if( PFdbiso/pfPho.pt < 1.)  {
            photemp.push_back(pfPho);
            pfphotonVec_.push_back(pfPho);
          }
        }
      }
        looseElePhoFSRpair_.push_back( std::make_pair(ele,photemp) );
    }
std::cout<<"POBJ looseeleVec//looseElePhoFSRpair size="<<looseeleVec_.size()<<"//"<<looseElePhoFSRpair_.size() << "\n";

 
 // }
}
////////////////////clear lists/////////////////
void LeptonSync::clearLists() {
  clearEvent();  
  loosemuVec_.clear();
  tightmuVec_.clear();
  looseeleVec_.clear();
  tighteleVec_.clear();
  pfphotonVec_.clear();
  looseMuPhoFSRpair_.clear();
  looseElePhoFSRpair_.clear();
  //searchedEle_ = false;
  //searchedMu_ = false;
  //searchedPhoton_ = false;
 }



void LeptonSync::endJob() {
    //syncDumpf.close();
    closeFiles();
    
    histf()->cd();
    histf()->Write();
    histf()->Close();
    delete histf();
}












