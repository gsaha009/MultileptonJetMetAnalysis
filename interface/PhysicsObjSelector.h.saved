#ifndef __PhysicsObjSelector__hh
#define __PhysicsObjSelector__hh

#define NEL(x) (sizeof((x))/sizeof((x)[0]))

#include "configana.h"

#include <fstream>
#include <string>
#include <vector>
#include <map>
#include <algorithm>
#include <cmath>
#include "TLorentzVector.h"
#include "TVector.h"
#include "TProfile.h"

#include "PhysicsObjects.h"
#include "AnaBase.h"

class PhysicsObjSelector : public AnaBase{
  public :
    PhysicsObjSelector();
    virtual ~PhysicsObjSelector() {}
    virtual void bookHistograms();
    virtual bool beginJob();
    
   
    std::vector<vhtm::Muon>& getLooseMuList(){ return loosemuVec_;}
    std::vector<vhtm::Muon>& getTightMuList(){ return tightmuVec_;}
    std::vector<vhtm::Electron>& getLooseEleList(){ return looseeleVec_;}
    std::vector<vhtm::Electron>& getTightEleList(){ return tighteleVec_;}
    std::vector<vhtm::PackedPFCandidate>& getPFPhotonFSRList(){ return photonVec_; }
    const std::vector<std::pair<vhtm::Electron, std::vector<vhtm::PackedPFCandidate> > >& getLooseElePhotonPairList() const {return looseElePhotonPairVec_;}
    const std::vector<std::pair<vhtm::Electron, std::vector<vhtm::PackedPFCandidate> > >& getTightElePhotonPairList() const {return tightElePhotonPairVec_;}
    const std::vector<std::pair<vhtm::Muon, std::vector<vhtm::PackedPFCandidate> > >& getLooseMuPhotonPairList() const {return looseMuPhotonPairVec_;}
    const std::vector<std::pair<vhtm::Muon, std::vector<vhtm::PackedPFCandidate> > >& getTightMuPhotonPairList() const {return tightMuPhotonPairVec_;}

    void leptonCrossCleaning();
    void findObjects(double wt=1);
    void muonSelector(double wt=1);
    void electronSelector(double wt=1);
    void pfphotonSelector(double wt=1);
    
      template <class T>
  TLorentzVector getP4(const T& obj) const {
    TLorentzVector lv;
    lv.SetPtEtaPhiE(obj.pt, obj.eta, obj.phi, obj.energy);
    return lv;
  }
    
    /*{
        TLorentzVector lv;
        lv.SetPtEtaPhiE(obj.pt, obj.eta, obj.phi, obj.energy);
        return lv;
    }*/
    
    bool passedSuperClusterVeto(const vhtm::PackedPFCandidate& pfcand) const;
    void findClosestLepton(const vhtm::PackedPFCandidate& photon, std::pair<int,std::string>&  lepidxtype) const;
    bool crossCleaned(const vhtm::Electron& electron) const;
    static bool electronBDT(const vhtm::Electron& electron);
    void clear();
//from subrida
double findClosestLepton(const vhtm::PackedPFCandidate& pfPho, int& muindx, int& elindx) const {
  TLorentzVector phoP4 = getP4(pfPho);
  double dRmin = 999;
  muindx = -1;
  // First consider loose muons
  for (unsigned int i = 0; i < loosemuVec_.size(); ++i) {
    const vhtm::Muon& mu = loosemuVec_[i];
    TLorentzVector muP4 = getP4(mu);
    double dR = muP4.DeltaR(phoP4);
    if (dR < dRmin) {
      dRmin = dR;
      muindx = i;
    }
  }
  // Then consider loose electron
  elindx = -1;
  for (unsigned int i = 0; i < looseeleVec_.size(); ++i) {
    const vhtm::Electron& ele = looseeleVec_[i];
    TLorentzVector eleP4 = getP4(ele);
    double dR = eleP4.DeltaR(phoP4);
    if (dR < dRmin) {
      dRmin = dR;
      elindx = i;
    }
  }
  return dRmin;
}
  private :
    bool _dumpEvent;
    std::vector<vhtm::Muon> loosemuVec_, tightmuVec_;
    std::vector<vhtm::Electron> looseeleVec_, tighteleVec_;
    std::vector<vhtm::PackedPFCandidate> photonVec_;
    std::vector<std::pair<vhtm::Electron, std::vector<vhtm::PackedPFCandidate> > > looseElePhotonPairVec_;
    std::vector<std::pair<vhtm::Electron, std::vector<vhtm::PackedPFCandidate> > > tightElePhotonPairVec_;
    std::vector<std::pair<vhtm::Muon, std::vector<vhtm::PackedPFCandidate> > > looseMuPhotonPairVec_;
    std::vector<std::pair<vhtm::Muon, std::vector<vhtm::PackedPFCandidate> > > tightMuPhotonPairVec_;    bool searchedEle_,searchedMu_,searchedPhoton_;
 };
#endif
